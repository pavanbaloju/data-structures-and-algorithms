## Data Structures

- **Array**
- **Linked List**
- **Stack**
- **Queue**
- **Tree**
- **Graph**
- **Hash Table**
- **Heap**
- **Trie**
- **Set**
- **Map**

## Algorithms

- **Sorting**
- **Searching**
- **Recursion**
- **Tree traversals**
- **Graph algorithms**
- **Greedy algorithms**
- **Dynamic programming**
- **Backtracking**
- **Divide and conquer**
- **String algorithms**
- **Mathematical algorithms**
- **Bit manipulation**

# Common Data Structure and Algorithm (DSA) Patterns

## Array

1. **Two Pointers Technique:**
   - **Description:** Used for solving problems involving two pointers moving through the array simultaneously to find a solution efficiently. The technique is particularly useful when the array is sorted or can be modified to be sorted.
   - **Example Problems:** Two Sum, Three Sum, Container With Most Water.
   
2. **Sliding Window Technique:**
   - **Description:** Efficiently solve problems where you maintain a window over the array and move it according to certain conditions. This technique is useful for finding maximum/minimum subarrays/substrings or counting occurrences of certain elements within a window.
   - **Example Problems:** Longest Substring Without Repeating Characters, Minimum Size Subarray Sum.
   
3. **Prefix Sum Technique:**
   - **Description:** Precompute cumulative sums to solve problems more efficiently. This technique is particularly useful when dealing with problems involving ranges or subarrays and needing to calculate sums over them.
   - **Example Problems:** Subarray Sum Equals K, Maximum Subarray Sum.
   
4. **Binary Search Technique:**
   - **Description:** Utilized for problems where the array is sorted or can be modified to be sorted, and you need to find an element efficiently. Binary search is a divide-and-conquer algorithm that repeatedly divides the search interval in half.
   - **Example Problems:** Binary Search, Search in Rotated Sorted Array.

## String

1. **Sliding Window Technique:**
   - **Description:** Often used to solve string problems efficiently by maintaining a window over the string and moving it according to certain conditions. This technique is useful for finding substrings or subsequences that satisfy certain criteria.
   - **Example Problems:** Longest Substring Without Repeating Characters, Minimum Window Substring.
   
2. **Two Pointers Technique:**
   - **Description:** Useful for problems where you need to compare elements or substrings in a string. This technique typically involves maintaining two pointers that move through the string in different directions or at different speeds.
   - **Example Problems:** Valid Palindrome, Longest Palindromic Substring.
   
3. **Hash Map Technique:**
   - **Description:** Utilized for problems involving frequency counting, anagrams, or substring matching. This technique involves using a hash map to store character frequencies or other relevant information.
   - **Example Problems:** Group Anagrams, Find All Anagrams in a String.
   
4. **Prefix/Suffix Techniques:**
   - **Description:** Precompute prefix or suffix arrays to solve problems more efficiently. These techniques are particularly useful when dealing with problems involving common prefixes or suffixes in strings.
   - **Example Problems:** Longest Common Prefix, Longest Palindromic Substring.

## Linked List

1. **Two Pointers Technique:**
   - **Description:** Used for solving problems involving linked lists efficiently by moving two pointers at different speeds. This technique is particularly useful for detecting cycles or finding intersections in linked lists.
   - **Example Problems:** Linked List Cycle, Intersection of Two Linked Lists.
   
2. **Fast and Slow Pointers Technique:**
   - **Description:** Used to detect cycles or find middle elements efficiently in linked lists. This technique typically involves using two pointersâ€”one that moves at a faster pace than the other.
   - **Example Problems:** Middle of the Linked List, Linked List Cycle II.
   
3. **Reversal Technique:**
   - **Description:** Reverse linked lists or portions of linked lists to solve problems efficiently. This technique is particularly useful for problems involving reversing the order of elements in a linked list.
   - **Example Problems:** Reverse Linked List, Reverse Nodes in k-Group.

## Tree

1. **Depth-First Search (DFS) Technique:**
   - **Description:** Traverse through trees in depth-first order, either recursively or iteratively. This technique is particularly useful for problems involving tree traversal or searching.
   - **Example Problems:** Binary Tree Preorder/Inorder/Postorder Traversal, Validate Binary Search Tree.
   
2. **Breadth-First Search (BFS) Technique:**
   - **Description:** Traverse through trees in breadth-first order using queues. This technique is particularly useful for problems involving level order traversal or shortest path finding.
   - **Example Problems:** Binary Tree Level Order Traversal, Minimum Depth of Binary Tree.
   
3. **Binary Search Technique:**
   - **Description:** Utilized for problems involving binary search trees (BSTs) to find elements efficiently. This technique is particularly useful for problems involving searching or inserting elements in a BST.
   - **Example Problems:** Search in Binary Search Tree, Kth Smallest Element in a BST.
   
4. **Inorder Traversal Technique:**
   - **Description:** Traverse binary trees in inorder to solve problems involving sorted data. This technique is particularly useful for problems involving finding the kth smallest/largest element in a BST.
   - **Example Problems:** Recover Binary Search Tree, Validate Binary Search Tree.

## Dynamic Programming (DP)

1. **Memoization Technique:**
   - **Description:** Store results of subproblems to avoid redundant computations. This technique is particularly useful for problems involving overlapping subproblems.
   - **Example Problems:** Fibonacci Number, Climbing Stairs.
   
2. **Tabulation Technique:**
   - **Description:** Build solutions bottom-up by filling a table iteratively. This technique is particularly useful for problems involving optimal substructure.
   - **Example Problems:** Longest Increasing Subsequence, Coin Change.
   
3. **Knapsack Problems:**
   - **Description:** Solve problems involving optimization over subsets of elements efficiently. This technique is particularly useful for problems involving maximizing/minimizing a value subject to certain constraints.
   - **Example Problems:** 0/1 Knapsack, Subset Sum.
   
4. **Optimal Substructure Technique:**
   - **Description:** Break down problems into smaller subproblems with optimal solutions. This technique is particularly useful for problems involving finding the optimal solution from the optimal solutions of its subproblems.
   - **Example Problems:** Longest Common Subsequence, Edit Distance.

# Common Data Structure and Algorithm (DSA) Patterns

## Array

1. **Two Pointers Technique:**
   - **Description:** Used for solving problems involving two pointers moving through the array simultaneously to find a solution efficiently. The technique is particularly useful when the array is sorted or can be modified to be sorted.
   - **Example Problems:** Two Sum, Three Sum, Container With Most Water.
   
2. **Sliding Window Technique:**
   - **Description:** Efficiently solve problems where you maintain a window over the array and move it according to certain conditions. This technique is useful for finding maximum/minimum subarrays/substrings or counting occurrences of certain elements within a window.
   - **Example Problems:** Longest Substring Without Repeating Characters, Minimum Size Subarray Sum.
   
3. **Prefix Sum Technique:**
   - **Description:** Precompute cumulative sums to solve problems more efficiently. This technique is particularly useful when dealing with problems involving ranges or subarrays and needing to calculate sums over them.
   - **Example Problems:** Subarray Sum Equals K, Maximum Subarray Sum.
   
4. **Binary Search Technique:**
   - **Description:** Utilized for problems where the array is sorted or can be modified to be sorted, and you need to find an element efficiently. Binary search is a divide-and-conquer algorithm that repeatedly divides the search interval in half.
   - **Example Problems:** Binary Search, Search in Rotated Sorted Array.

## String

1. **Sliding Window Technique:**
   - **Description:** Often used to solve string problems efficiently by maintaining a window over the string and moving it according to certain conditions. This technique is useful for finding substrings or subsequences that satisfy certain criteria.
   - **Example Problems:** Longest Substring Without Repeating Characters, Minimum Window Substring.
   
2. **Two Pointers Technique:**
   - **Description:** Useful for problems where you need to compare elements or substrings in a string. This technique typically involves maintaining two pointers that move through the string in different directions or at different speeds.
   - **Example Problems:** Valid Palindrome, Longest Palindromic Substring.
   
3. **Hash Map Technique:**
   - **Description:** Utilized for problems involving frequency counting, anagrams, or substring matching. This technique involves using a hash map to store character frequencies or other relevant information.
   - **Example Problems:** Group Anagrams, Find All Anagrams in a String.
   
4. **Prefix/Suffix Techniques:**
   - **Description:** Precompute prefix or suffix arrays to solve problems more efficiently. These techniques are particularly useful when dealing with problems involving common prefixes or suffixes in strings.
   - **Example Problems:** Longest Common Prefix, Longest Palindromic Substring.

## Linked List

1. **Two Pointers Technique:**
   - **Description:** Used for solving problems involving linked lists efficiently by moving two pointers at different speeds. This technique is particularly useful for detecting cycles or finding intersections in linked lists.
   - **Example Problems:** Linked List Cycle, Intersection of Two Linked Lists.
   
2. **Fast and Slow Pointers Technique:**
   - **Description:** Used to detect cycles or find middle elements efficiently in linked lists. This technique typically involves using two pointersâ€”one that moves at a faster pace than the other.
   - **Example Problems:** Middle of the Linked List, Linked List Cycle II.
   
3. **Reversal Technique:**
   - **Description:** Reverse linked lists or portions of linked lists to solve problems efficiently. This technique is particularly useful for problems involving reversing the order of elements in a linked list.
   - **Example Problems:** Reverse Linked List, Reverse Nodes in k-Group.

## Tree

1. **Depth-First Search (DFS) Technique:**
   - **Description:** Traverse through trees in depth-first order, either recursively or iteratively. This technique is particularly useful for problems involving tree traversal or searching.
   - **Example Problems:** Binary Tree Preorder/Inorder/Postorder Traversal, Validate Binary Search Tree.
   
2. **Breadth-First Search (BFS) Technique:**
   - **Description:** Traverse through trees in breadth-first order using queues. This technique is particularly useful for problems involving level order traversal or shortest path finding.
   - **Example Problems:** Binary Tree Level Order Traversal, Minimum Depth of Binary Tree.
   
3. **Binary Search Technique:**
   - **Description:** Utilized for problems involving binary search trees (BSTs) to find elements efficiently. This technique is particularly useful for problems involving searching or inserting elements in a BST.
   - **Example Problems:** Search in Binary Search Tree, Kth Smallest Element in a BST.
   
4. **Inorder Traversal Technique:**
   - **Description:** Traverse binary trees in inorder to solve problems involving sorted data. This technique is particularly useful for problems involving finding the kth smallest/largest element in a BST.
   - **Example Problems:** Recover Binary Search Tree, Validate Binary Search Tree.

## Dynamic Programming (DP)

1. **Memoization Technique:**
   - **Description:** Store results of subproblems to avoid redundant computations. This technique is particularly useful for problems involving overlapping subproblems.
   - **Example Problems:** Fibonacci Number, Climbing Stairs.
   
2. **Tabulation Technique:**
   - **Description:** Build solutions bottom-up by filling a table iteratively. This technique is particularly useful for problems involving optimal substructure.
   - **Example Problems:** Longest Increasing Subsequence, Coin Change.
   
3. **Knapsack Problems:**
   - **Description:** Solve problems involving optimization over subsets of elements efficiently. This technique is particularly useful for problems involving maximizing/minimizing a value subject to certain constraints.
   - **Example Problems:** 0/1 Knapsack, Subset Sum.
   
4. **Optimal Substructure Technique:**
   - **Description:** Break down problems into smaller subproblems with optimal solutions. This technique is particularly useful for problems involving finding the optimal solution from the optimal solutions of its subproblems.
   - **Example Problems:** Longest Common Subsequence, Edit Distance.

## Graph

1. **Depth-First Search (DFS) Technique:**
   - **Description:** Traverse through graphs in depth-first order, either recursively or iteratively. This technique is particularly useful for problems involving graph traversal or searching.
   - **Example Problems:** Depth-First Search, Number of Islands.
   
2. **Breadth-First Search (BFS) Technique:**
   - **Description:** Traverse through graphs in breadth-first order using queues. This technique is particularly useful for problems involving shortest path finding or level order traversal.
   - **Example Problems:** Breadth-First Search, Shortest Path in a Grid with Obstacles Elimination.
   
3. **Topological Sorting Technique:**
   - **Description:** Sort directed acyclic graphs (DAGs) efficiently. This technique is particularly useful for problems involving dependencies or scheduling.
   - **Example Problems:** Course Schedule, Alien Dictionary.
   
4. **Minimum Spanning Tree (MST) Technique:**
   - **Description:** Find minimum spanning trees in graphs using algorithms like Prim's or Kruskal's. This technique is particularly useful for problems involving connecting all nodes with minimum total edge weight.
   - **Example Problems:** Minimum Spanning Tree, Network Delay Time.

## Backtracking

1. **Decision Space Exploration Technique:**
   - **Description:** Explore all possible solutions incrementally, backtracking when a dead-end is reached. This technique is particularly useful for problems involving combinatorial search or exhaustive search.
   - **Example Problems:** N-Queens, Sudoku Solver.
   
2. **State Space Exploration Technique:**
   - **Description:** Explore the state space of a problem by systematically generating and testing candidate solutions. This technique is particularly useful for problems involving optimization or constraint satisfaction.
   - **Example Problems:** Generate Parentheses, Combination Sum.
   
3. **Optimization Pruning Technique:**
   - **Description:** Prune the search space by eliminating portions that are known to be invalid or less optimal. This technique is particularly useful for problems involving optimization or search.
   - **Example Problems:** Word Search II, Palindrome Partitioning.

## Greedy Algorithms

1. **Greedy Choice Property:**
   - **Description:** Make locally optimal choices at each step with the hope of finding a global optimum. Greedy algorithms are used for optimization problems where a sequence of choices needs to be made.
   - **Example Problems:** Fractional Knapsack, Activity Selection.

2. **Interval Scheduling:**
   - **Description:** Schedule resources to minimize overlapping intervals or maximize the number of intervals scheduled. This technique is often used in job scheduling or resource allocation problems.
   - **Example Problems:** Interval Scheduling, Minimum Number of Arrows to Burst Balloons.

## Divide and Conquer

1. **Divide Step:**
   - **Description:** Divide the problem into smaller subproblems that can be solved independently. This technique is used to break down complex problems into simpler ones.
   - **Example Problems:** Merge Sort, Quick Sort.

2. **Conquer Step:**
   - **Description:** Solve each subproblem recursively. This technique involves solving the subproblems using the same approach until they become base cases.
   - **Example Problems:** Closest Pair of Points, Maximum Subarray Sum.

## Graph Algorithms

1. **Shortest Paths:**
   - **Description:** Find the shortest paths between vertices in a graph. Shortest path algorithms are used to solve problems involving finding the most efficient routes or paths.
   - **Example Problems:** Dijkstra's Algorithm, Bellman-Ford Algorithm.

2. **Maximum Flow:**
   - **Description:** Find the maximum flow that can be sent through a flow network. Maximum flow algorithms are used in problems involving network flow optimization.
   - **Example Problems:** Ford-Fulkerson Algorithm, Edmonds-Karp Algorithm.

3. **Graph Coloring:**
   - **Description:** Assign colors to vertices of a graph such that no two adjacent vertices have the same color. Graph coloring algorithms are used in scheduling, register allocation, and other optimization problems.
   - **Example Problems:** Graph Coloring, Minimum Number of Colors Required to Color a Graph.

## Advanced Data Structures

1. **Trie (Prefix Tree):**
   - **Description:** A tree-like data structure used to store a dynamic set of strings. Tries are commonly used for fast searching of strings or pattern matching.
   - **Example Problems:** Implement Trie (Prefix Tree), Word Search II.


# Top 10 Problem Types for Data Structures and Algorithms

## Data Structures

### Array
1. Two Pointer Technique
2. Sliding Window Technique
3. Prefix Sum Technique
4. Binary Search Technique
5. Sorting and Searching
6. Kadane's Algorithm (Maximum Subarray)
7. Merge Intervals
8. Partitioning Arrays
9. Trapping Rain Water
10. Product of Array Except Self

### Linked List
1. Reverse Linked List
2. Merge Two Sorted Lists
3. Detect Cycle in a Linked List
4. Remove Nth Node From End of List
5. Intersection of Two Linked Lists
6. Convert Sorted List to Binary Search Tree
7. Flatten a Multilevel Doubly Linked List
8. Palindrome Linked List
9. Insertion Sort List
10. Copy List with Random Pointer

### Stack
1. Valid Parentheses
2. Evaluate Reverse Polish Notation
3. Min Stack
4. Next Greater Element
5. Largest Rectangle in Histogram
6. Simplify Path
7. Design a Stack that supports push, pop, top, and retrieving the minimum element in constant time.
8. Implement Queue using Stacks
9. Longest Valid Parentheses
10. Asteroid Collision

### Queue
1. Implement Queue using Stacks
2. Design Circular Queue
3. Implement Stack using Queues
4. Sliding Window Maximum
5. Design Twitter
6. Number of Recent Calls
7. Perfect Squares
8. Moving Average from Data Stream
9. Implement Stack using Queues
10. Reconstruct the Queue

### Tree
1. Maximum Depth of Binary Tree
2. Validate Binary Search Tree
3. Binary Tree Level Order Traversal
4. Lowest Common Ancestor of Binary Tree
5. Binary Tree Zigzag Level Order Traversal
6. Construct Binary Tree from Preorder and Inorder Traversal
7. Binary Tree Maximum Path Sum
8. Symmetric Tree
9. Serialize and Deserialize Binary Tree
10. Closest Binary Search Tree Value

### Graph
1. Number of Islands
2. Course Schedule
3. Shortest Path in a Grid with Obstacles Elimination
4. Clone Graph
5. Word Ladder
6. Graph Valid Tree
7. Number of Connected Components in an Undirected Graph
8. Pacific Atlantic Water Flow
9. Minimum Height Trees
10. Alien Dictionary

### Hash Table
1. Two Sum
2. Group Anagrams
3. Intersection of Two Arrays
4. Longest Substring Without Repeating Characters
5. Minimum Window Substring
6. Isomorphic Strings
7. Word Pattern
8. Subarray Sum Equals K
9. Top K Frequent Elements
10. Design Twitter

### Heap
1. Kth Largest Element in an Array
2. Merge K Sorted Lists
3. Top K Frequent Elements
4. Find Median from Data Stream
5. Sliding Window Median
6. Design Twitter
7. Super Ugly Number
8. K Closest Points to Origin
9. Find K Pairs with Smallest Sums
10. Rearrange String k Distance Apart

### Trie
1. Implement Trie (Prefix Tree)
2. Word Search II
3. Prefix and Suffix Search
4. Replace Words
5. Design Add and Search Words Data Structure
6. Longest Word in Dictionary
7. Stream of Characters
8. Add and Search Word - Data structure design
9. Magic Dictionary
10. Implement Trie II

### Set
1. Intersection of Two Arrays
2. Contains Duplicate
3. Happy Number
4. Valid Sudoku
5. Count Primes
6. Intersection of Two Arrays II
7. Valid Palindrome
8. Valid Anagram
9. Missing Number
10. Happy Number

### Map
1. Two Sum
2. Most Common Word
3. Group Anagrams
4. Longest Substring Without Repeating Characters
5. Longest Consecutive Sequence
6. Subarray Sum Equals K
7. Minimum Window Substring
8. Isomorphic Strings
9. Valid Sudoku
10. Word Pattern

## Algorithms

### Sorting
1. Merge Sort
2. Quick Sort
3. Heap Sort
4. Counting Sort
5. Radix Sort
6. Bucket Sort
7. Selection Sort
8. Bubble Sort
9. Insertion Sort
10. Shell Sort

### Searching
1. Binary Search
2. Search in Rotated Sorted Array
3. Find First and Last Position of Element in Sorted Array
4. Peak Element
5. Search Insert Position
6. Search a 2D Matrix
7. First Bad Version
8. Find Minimum in Rotated Sorted Array
9. Search in Rotated Sorted Array II
10. Search a 2D Matrix II

### Recursion
1. Fibonacci Number
2. Factorial
3. Tower of Hanoi
4. Generate Parentheses
5. Unique Paths
6. Climbing Stairs
7. Binary Tree Paths
8. Subsets
9. Combination Sum
10. Palindrome Partitioning

### Tree Traversals
1. Preorder Traversal
2. Inorder Traversal
3. Postorder Traversal
4. Level Order Traversal
5. Zigzag Level Order Traversal
6. Vertical Order Traversal
7. Boundary Traversal of Binary Tree
8. Morris Traversal
9. Convert Binary Search Tree to Sorted Doubly Linked List
10. Recover Binary Search Tree

### Graph Algorithms
1. Depth-First Search (DFS)
2. Breadth-First Search (BFS)
3. Dijkstra's Algorithm
4. Bellman-Ford Algorithm
5. Floyd-Warshall Algorithm
6. Kruskal's Algorithm
7. Prim's Algorithm
8. Topological Sorting
9. Ford-Fulkerson Algorithm
10. Bipartite Graph Check

### Greedy Algorithms
1. Fractional Knapsack
2. Activity Selection
3. Coin Change
4. Minimum Number of Arrows to Burst Balloons
5. Minimum Spanning Tree
6. Maximum Subarray
7. Jump Game
8. Gas Station
9. Queue Reconstruction by Height
10. Non-overlapping Intervals

### Dynamic Programming
1. Fibonacci Number
2. Longest Increasing Subsequence
3. Knapsack Problems
4. Edit Distance
5. Longest Common Subsequence
6. Coin Change
7. Maximum Subarray
8. House Robber
9. Matrix Chain Multiplication
10. Longest Palindromic Subsequence

### Backtracking
1. N-Queens
2. Sudoku Solver
3. Letter Combinations of a Phone Number
4. Generate Parentheses
5. Combination Sum
6. Permutations
7. Word Search
8. Subsets
9. Palindrome Partitioning
10. Restore IP Addresses

### Divide and Conquer
1. Merge Sort
2. Quick Sort
3. Closest Pair of Points
4. Maximum Subarray Sum
5. Count Inversions
6. Majority Element
7. Search in Rotated Sorted Array
8. Find Minimum in Rotated Sorted Array
9. Maximum Product Subarray
10. Find Kth Smallest Element in a Sorted Matrix

### String Algorithms
1. Longest Palindromic Substring
2. String Matching
3. Reverse Words in a String
4. Valid Palindrome
5. Regular Expression Matching
6. Longest Substring Without Repeating Characters
7. Implement strStr()
8. Longest Common Subsequence
9. Valid Parentheses
10. Decode String

### Mathematical Algorithms
1. Factorial
2. Fibonacci Number
3. Prime Number Generation
4. GCD and LCM
5. Power of Two
6. Reverse Integer
7. Palindrome Number
8. Roman to Integer
9. Integer to English Words
10. Fraction to Recurring Decimal

### Bit Manipulation
1. Single Number
2. Bitwise AND of Numbers Range
3. Counting Bits
4. Reverse Bits
5. Hamming Distance
6. Power of Two
7. Number of 1 Bits
8. Missing Number
9. Majority Element
10. Maximum XOR of Two Numbers in an Array
