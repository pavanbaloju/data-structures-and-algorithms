#include <iostream>
#include <vector>
using namespace std;

// Problem Statement:
// Given a row number 'r' and column number 'c', find the element at position (r, c) in Pascal's Triangle.
// Also, generate Pascal's Triangle up to the nth row.

// Function to calculate combination (nCr) using Pascal's triangle logic.
// Intuition:
// - Pascal's Triangle is constructed using combinations.
// - Each element in Pascal's Triangle is the combination of the row number (n) and the position in the row (r).
// - Combinations can be calculated using the formula nCr = (N * (N - 1) * ... * (N - R + 1)) / (1 * 2 * ... * R).
// Approach:
// - Use the formula to calculate the combination for a given row number 'N' and position 'R'.
// Time Complexity: O(R), where R is the position in the row.
// Space Complexity: O(1).
int nCr(int N, int R)
{
    long long res = 1;

    // Calculate nCr using the formula nCr = (N * (N - 1) * ... * (N - R + 1)) / (1 * 2 * ... * R)
    for (int r = 0; r < R; r++)
    {
        res = res * (N - r);
        res = res / (r + 1);
    }
    return res;
}

// Function to get the element at a specific position (r, c) in Pascal's Triangle.
// Intuition:
// - The element at position (r, c) in Pascal's Triangle is given by the combination (r-1) choose (c-1).
// Approach:
// - Call the nCr function with (r-1) and (c-1) to get the element at position (r, c).
// Time Complexity: O(c), where c is the column number.
// Space Complexity: O(1).
int pascalTriangle(int r, int c)
{
    return nCr(r - 1, c - 1); // Call nCr to get the element at position (r, c).
}

// Function to generate a single row of Pascal's Triangle.
// Intuition:
// - Each row in Pascal's Triangle can be generated using combinations.
// - Start with the first element as 1, then calculate each subsequent element using the combination formula.
// Approach:
// - Initialize the row with 1 as the first element.
// - Generate the remaining elements of the row using combination logic.
// Time Complexity: O(N), where N is the number of elements in the row.
// Space Complexity: O(N), where N is the number of elements in the row.
vector<int> generateRow(int N)
{
    vector<int> row{1}; // Initialize the row with 1 as the first element.

    // Generate the remaining elements of the row using combination logic.
    int ans = 1;
    for (int r = 1; r < N; r++)
    {
        ans = ans * (N - r);
        ans = ans / r;
        row.push_back(ans);
    }

    return row;
}

// Function to generate Pascal's Triangle up to the nth row.
// Intuition:
// - Pascal's Triangle can be generated by calculating each row individually.
// Approach:
// - Generate each row of Pascal's Triangle and add it to the answer.
// Time Complexity: O(n^2), where n is the number of rows in Pascal's Triangle.
// Space Complexity: O(n^2), where n is the number of rows in Pascal's Triangle.
vector<vector<int>> pascalTriangle(int n)
{
    vector<vector<int>> ans; // Initialize the vector to store Pascal's Triangle.

    // Generate each row of Pascal's Triangle and add it to the answer.
    for (int row = 1; row <= n; row++)
        ans.push_back(generateRow(row));

    return ans;
}

// Function to print a vector.
void print(vector<int> &nums)
{
    for (int x : nums)
        cout << x << " "; // Print each element separated by space.
    cout << endl;
}

// Main function
int main()
{
    int r = 5; // Row number
    int c = 3; // Column number

    // Calculate and print the element at position (r, c) in Pascal's Triangle.
    int element = pascalTriangle(r, c);
    cout << "The element at position (r, c) is: " << element << endl << endl;

    // Generate and print a specific row of Pascal's Triangle.
    vector<int> row = generateRow(5);
    cout << "Row 5 of Pascal's Triangle:" << endl;
    print(row);
    cout << endl;

    // Generate and print Pascal's Triangle up to the 5th row.
    vector<vector<int>> pt = pascalTriangle(5);
    cout << "Pascal's Triangle up to the 5th row:" << endl;
    for (auto row : pt)
        print(row);

    return 0;
}
